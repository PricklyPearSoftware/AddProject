
//**********************************************************************************************************************************
//
//   Purpose: Add Project Utility source code file
//
//   Project: Development Utilities
//
//  Filename: AddProject.cpp
//
//   Authors: Caroline.M.Mathieson (CMM)
//
//**********************************************************************************************************************************
//
//  Description
//  -----------
//
//! \file AddProject.cpp
//! \brief Contains the complete implementation of the AddProject Utility.
//!
//**********************************************************************************************************************************

/** \mainpage

This utility is designed to generate a complete directory tree for a project from the specification of the project layout and the
set of source template files. I have written this utility for the simulator project as it became obvious from the complexity of the
simulator initial design, that there would be a huge number of source code files in the project and that naturally these files would
be very similar both in layout and to some degree content since many of the files would be implementing derived objects and
therefore there would be some boiler plate code duplication. I did not want to be generating all these files by hand when it seemed
to be possible to automate the process. This had a secondary benefit in that I could start to get a good idea of the likely size of
the final source code. 

Designing any system requires first examining the problem domain so that the solution reflects the structure of problem.

So I started out by looking at the problem domain, which then led to how to specify the structure of the resulting software project.

\section ProblemDomain The Problem Domain

In this case the problem domain is how to automate the process of creating a large source code repository, containing source code
files with a consistent layout and style, and which is a consequence of the design process of the person or organisation using the
utility rather than the creator of that utility. This means that all the files to be used must be supplied to the utility and
processed by it rather than being generated by it. The layout of the source code repository also needs to be under user control. 

A 3GPP specified telecommunications system consists of Network Elements, Protocols, Interfaces and Services and many other concepts.
Within each of these conceptual groupings there are individual parts which communicate with each other using shared messages defined
using a specific notation such as TLV or ASN and grouped in layers according to a protocol stack. 

It seemed clear that for the telecommunications simulators, I would need an overall executable which the user would run and this
would then invoke the various other applications or libraries for each simulated network element etc. These executables would be
connected together over a network using sockets. 

The simulator would need to include a method of specifying the telecommunications network(s) to be simulated. 

The solution would consist of a software defined system which would have source code files and documentation files. There would be
documentation files for the end user and documentation files describing the design. 

So how do we go about describing this software defined system?

\section GenericProblemDomainModel Generic Problem Domain Model

A software project consists of one or more source code repositories each consisting of a directory hierarchy populated with source
code files and documentation files. The names of the directories would reflect the purpose of the contents of the directory and the
directory hierarchy would in some way reflect the hierarchy in the problem domain. The naming of the directories would be consistent
and within a directory with a specific purpose in the problem domain, there would be specific directories for source files, header
files and documentation files etc as this is typically normal practise rather than having every file in the same directory. There
would also be directories for test harness files and test tool files.

The utility should not impose a particular directory structure but should allow the user to define the required structure.

An example directory structure within a directory could be:-

- DirectoryName                  (representing a domain object)
  - Documentation                (documentation for the domain object)
    - Design                     (documents the design and implementation of the domain object)
    - User                       (documents for the end user)
  - Implementation               (the actual implementation of the domain object)
    - Common                     (files which are commen between multiple domain objects)
    - Export                     (header files defining the external interface for this object)
    - Header                     (header files for this domain object)
    - Model                      (SDL or UML models which will be later converted to code)
    - Object                     (the output from the build process or prebuilt libraries)
    - Source                     (one file per part of the implementation of domain object)
    - Tools                      (Any tools used to generate fixed content tables etc)
  - Test                         (Test Harness for testing the full domain object or its parts)
  - Templates                    (Template files for all of the files in the above directories)
    - Documentation
      - Design
      - User
    - Implementation 
      - Common
      - Export  
      - Header
      - Model
      - Source
      - Tools
    - Testing
  
The different "documentation", "implementation" and "testing" sub directories are grouped in subdirectories with those names. This
helps when browsing a directory tree for a particular domain object. 

It is assumed that the generated project tree may be updated afterwards with seperate tools and so template source code files and
documentation files would be required, when these tools need to add new files to the project. 

The maximum number of levels in the directory tree which can be defined is currently 10. This should be sufficient to define most
projects and most hierarchical file systems do not in fact support many more levels than this. There will also be a file system
specific limit to the maximum length of a full path name for a file within the tree. The names of the domain objects may have to be
chosen carefully to keep within these constraints. 

NOTE: The rest of the description below uses the simulator domain specific names, but the actual names of each level in the
hierarchy for the problem domain can be specified in the initialisation file. 

\section Hierarchy The Project Hierarchy 

The whole project structure is specified using two parts, the <b>ProjectSpecificationFilename</b> passed in as the first command
line argument to the utility. The content of the project is defined by the second argument, the <b>TemplateDirectoryName</b> which
points to a set of template files which will be processed to generate the final source files. 

When the Project Specification File has been processed, the resulting project definition is stored in memory as a hierarchical tree
of NODE objects as shown in the following example:-

- "project"
  - "domain"                    (one or more)
    - "system"                  (one or more)
      - "division"              (one or more)
        - "section"             (one or more)
          - "group"             (one or more)
            - "application"     (one or more)
              - "module"        (one or more)
                - "block"       (one or more)
                  - "component" (one or more)
                    - "etc"

The "Root" of the tree would be represented by a NODE object of type "Project" and whose name defines the top level directory name.
This NODE object would contain one ore more sub NODE objects of type "Domain" which would define the major areas such as "Network
Element" etc. These would then contain one or more NODE objects of type "System" which define the actual executable library or
executable files such as "BaseStation". The hierarchy would normally extend even lower than this.

So for example for a simulator we might have:-

- GERANSystemSimulator       (Project)
  - NetworkElement           (Domain)
    - BaseStation            (System)
    - BaseStationController  (System)
  - Interface                (Domain)
    - AInterface             (System)
    - GInterface             (System)
  - Protocol                 (Domain)
    - BSSMAP                 (System)
    - GTP                    (System)
  - Service                  (Domain)
    - VoiceCall              (System)
    - DataCall               (System)

\section TemplateDirectory The Template Directory

When the Project Specification File is parsed and the NODE tree created, the end result is a set of filenames of the template files
to be processed to populate the resulting directory tree created during the "build" phase. 

A template file can contain pure text which will be copied straight through into the final file, but it can also contain MACROs
which are expanded during the processing of the file. These macros are the basis of the flexibility of the utility. 

The template directory is sub divided into template files for the different levels in the project hierarchy. So the template
directory will contain subdirectories as follows:-

- TemplateDirectoryName
  - Project
  - Group
  - Application
  - Module
  - etc

This allows there to be different boiler plate code for each level in the hierarchy. The files can in fact have the same content,
but having seperate files allows the use of different macros in the template files, which is more flexible. 

\subsection TemplateTypes The Template File Types 

Within a particular project NODE, there are different types of template files, \ref RootFile, \ref MasterFile, \ref SourceFile and
\ref TemplateFile. 

\subsubsection RootFile A Root File 

A RootFile is a file needed at the root of the Node. Its filename doesn't change. 

An example might be the index.htm file for the full documantation tree. Another example might be an image file or a style sheet
file. 

\subsubsection MasterFile A Master File 

A Masterfile is a file who's name does not change. It can be a source code file (.c or .h etc) or a documentation file. It will end
up in either the Source or Header directory depending on its extension. 

Example master files are files which are not supposed to change from one project to the next because they contain classes used
throughout all projects. An example would be the source code files for the implementation of the OBJECT class which every other
object in a system is ultimately derived from. 

\subsubsection SourceFile A Source File 

A SourceFile has it's name prefixed by the name of the Node etc. It can also be a source code file (.c or .h etc) or a documentation
file. It will end up in either the Source or Header directory depending on its extension. 

These exist because it is likely that there will be classes derived from a base class. The name of the derivative is likely to be
based on a concatenation of the domain specific name and a more general name e.g. BaseStationApplicationClass.c which would contain
the implementation of a BASE_STATION class derived from the APPLICATION class. 

\subsubsection TemplateFile A Template File 

A TemplateFile may or may not have it's name changed but it ends up in the appropriate Template directory depending on its
extension. 

These files don't get used right away, but are used when tools such as the MessageTool are run later to generate code from any
message definitions. 

\section ProjectSpecificationFile The Project Specification File

In order to specify the layout of the project, I choose to use the standard windows initialisation file as the Win32 API has good
support for managing these and the files can actually handle any level of complexity provided that there is a logic to the key
names and that the keynames are unique.

The Project Specification File contains a set of key/value pairs. At the top of the file is a section for the project. Following
that, each group is defined and then after that the applications. Each section is delineated with the section heading in [] brackets.

A typical project specification file might look like this:-

<pre>
<code>

[Project]
ProjectName        = GERAN System Simulator
CompanyName        = Telecommunication Simulators
CompanyWebAddress  = TelecommunicationsSimulators.com
AuthorName         = Caroline.M.Mathieson
AuthorInitials     = CMM
SourceFileWidth    = 132
SeperatorCharacter = *

NumberOfDomains

Domain1 = Network Element
Domain2 = Interface
Domain3 = Protocol
Domain4 = Service

[Project Core Files]
[Project Master Files]
[Project Template Files]
[Project Source Files]

[Domain Core Files]
[Domain Master Files]
[Domain Template Files]
[Domain Source Files]

[System Core Files]
[System Master Files]
[System Template Files]
[System Source Files]

[Division Core Files]
[Division Master Files]
[Division Template Files]
[Division Source Files]

[Section Core Files]
[Section Master Files]
[Section Template Files]
[Section Source Files]

[Group Core Files]
[Group Master Files]
[Group Template Files]
[Group Source Files]

[Application Core Files]
[Application Master Files]
[Application Template Files]
[Application Source Files]

[Module Core Files]
[Module Master Files]
[Module Template Files]
[Module Source Files]

[Block Core Files]
[Block Master Files]
[Block Template Files]
[Block Source Files]

[Component Core Files]
[Component Master Files]
[Component Template Files]
[Component Source Files]

</code>
</pre>

More sections then follow with the titles of each group and application specifying more details for each individual group and
application etc.

**/

//**********************************************************************************************************************************

#include "AddProject.h"

//**********************************************************************************************************************************

static TOOL *Tool = NULL;

//**********************************************************************************************************************************

static CHARACTER TitleText [] =
{
    "\n"
    "           Add Project Utility\n"
    "              Version 0.0.8\n"
    "(c) Prickly Pear Software 12th April 2017\n"
    "\n"
};

//**********************************************************************************************************************************

static CHARACTER HelpText [] =
{
   "Usage: ADDPROJECT ProjectSpecificationFileName TemplateDirectoryName [OutputDirectoryName]\n"
   "\n"
   "       This utility will generate a directory tree for a project given the name of the file containing the specification\n"
   "       of the project layout, 'ProjectSpecificationFileName' and the location of the directory containing standard project\n"
   "       master template files, 'TemplateDirectoryName'. An optional output directory, 'OutputDirectoryName' can be specified.\n"
   "\n"
   "       The initial directory will be generated starting from the point where this utility is invoked unless the output\n"
   "       directory is specified.\n"
   "\n"
};

//**********************************************************************************************************************************

static NUMBER NumberOfRootFileTypes = 10;

static INITIALISATION_TABLE_ENTRY RootFileTypesTable [] =
{
//   ------------------------------------------------------------------------------------
//  | KeyName                             TemplateType           Directory               |
//  |------------------------------------------------------------------------------------|
    { "NumberOfHeaderFiles",              "Header",              "Header"                },
    { "NumberOfSourceCodeFiles",          "Source Code",         "Source"                },
    { "NumberOfResourceHeaderFiles",      "Resource Header",     "Header"                },
    { "NumberOfResourceScriptFiles",      "Resource Script",     "Source"                },
    { "NumberOfRootDocumentationFiles",   "Root Document",       ""                      },
    { "NumberOfUserDocumentationFiles",   "User Document",       "Documentation\\User"   },
    { "NumberOfDesignDocumentationFiles", "Design Document",     "Documentation\\Design" },
    { "NumberOfClassDiagramFiles",        "Class Diagram",       "Model"                 },
    { "NumberOfMessageDefinitionFiles",   "Message Definition",  "Header"                },
    { "NumberOfRegisterDefinitionFiles",  "Register Definition", "Header"                }
//   ------------------------------------------------------------------------------------
};

//**********************************************************************************************************************************

static NUMBER NumberOfMasterFileTypes = 9;

static INITIALISATION_TABLE_ENTRY MasterFileTypesTable [] =
{
//   ------------------------------------------------------------------------------------
//  | KeyName                             TemplateType           Directory               |
//  |------------------------------------------------------------------------------------|
    { "NumberOfHeaderFiles",              "Header",              "Header"                },
    { "NumberOfSourceCodeFiles",          "Source Code",         "Source"                },
    { "NumberOfResourceHeaderFiles",      "Resource Header",     "Header"                },
    { "NumberOfResourceScriptFiles",      "Resource Script",     "Source"                },
    { "NumberOfUserDocumentationFiles",   "User Document",       "Documentation\\User"   },
    { "NumberOfDesignDocumentationFiles", "Design Document",     "Documentation\\Design" },
    { "NumberOfClassDiagramFiles",        "Class Diagram",       "Model"                 },
    { "NumberOfMessageDefinitionFiles",   "Message Definition",  "Header"                },
    { "NumberOfRegisterDefinitionFiles",  "Register Definition", "Header"                }
//   ------------------------------------------------------------------------------------
};

//**********************************************************************************************************************************

static NUMBER NumberOfTemplateFileTypes = 9;

static INITIALISATION_TABLE_ENTRY TemplateFileTypesTable [] =
{
//   ------------------------------------------------------------------------------------
//  | KeyName                             TemplateType           Directory               |
//  |------------------------------------------------------------------------------------|
    { "NumberOfHeaderFiles",              "Header",              "Header"                },
    { "NumberOfSourceCodeFiles",          "Source Code",         "Source"                },
    { "NumberOfResourceHeaderFiles",      "Resource Header",     "Header"                },
    { "NumberOfResourceScriptFiles",      "Resource Script",     "Source"                },
    { "NumberOfUserDocumentationFiles",   "User Document",       "Documentation\\User"   },
    { "NumberOfDesignDocumentationFiles", "Design Document",     "Documentation\\Design" },
    { "NumberOfClassDiagramFiles",        "Class Diagram",       "Model"                 },
    { "NumberOfMessageDefinitionFiles",   "Message Definition",  "Header"                },
    { "NumberOfRegisterDefinitionFiles",  "Register Definition", "Header"                }
//   ------------------------------------------------------------------------------------
};

//**********************************************************************************************************************************

static NUMBER NumberOfSourceFileTypes = 9;

static INITIALISATION_TABLE_ENTRY SourceFileTypesTable [] =
{
//   ------------------------------------------------------------------------------------
//  | KeyName                             TemplateType           Directory               |
//  |------------------------------------------------------------------------------------|
    { "NumberOfHeaderFiles",              "Header",              "Header"                },
    { "NumberOfSourceCodeFiles",          "Source Code",         "Source"                },
    { "NumberOfResourceHeaderFiles",      "Resource Header",     "Header"                },
    { "NumberOfResourceScriptFiles",      "Resource Script",     "Source"                },
    { "NumberOfUserDocumentationFiles",   "User Document",       "Documentation\\User"   },
    { "NumberOfDesignDocumentationFiles", "Design Document",     "Documentation\\Design" },
    { "NumberOfClassDiagramFiles",        "Class Diagram",       "Model"                 },
    { "NumberOfMessageDefinitionFiles",   "Message Definition",  "Header"                },
    { "NumberOfRegisterDefinitionFiles",  "Register Definition", "Header"                }
//   ------------------------------------------------------------------------------------
};

//**********************************************************************************************************************************

static NUMBER WheelTableSize = 4;
static NUMBER Wheel          = 0;

static CHARACTER WheelTable [] =
{
    '|',
    '/',
    '-',
    '\\'
};

//**********************************************************************************************************************************

/**

\brief The entry point to the utility. Creates an instance of the TOOL class with the command line arguments. 

On entry to the utility, the contents of the \ref TitleText variable is printed out on the command line giving the name of the
utility and some details about the version of the utility. 

The utility expects two arguments, the first is the full filename of the <b>ProjectSpecificationFileName</b> and the second is the
full filename of the <b>TemplateDirectoryFileName</b>. 

The <b>ProjectSpecificationFileName</b> argument specifies the file containing the hierarchical specification for the files, groups
and applications of the desired system. The <b>TemplateDirectoryFileName</b> argument specifies the location of the directory
containing all the template files to be used to generate the desired system. 

If one or both of these arguments are missing then the contents of the \ref HelpText variable is printed out onto the command line.
That text specifies how to invoke the utility and the meaning of the command line arguments. Otherwise an attempt is made to create
an instance of the TOOL class using these command line arguments and a copy of the resulting pointer kept in the global variable
\ref Tool. 

If the instantiation is successful, the \ref TOOL::Execute() member function is called. Then the TOOL object is deleted. 

If the TOOL object could not be instantiated then an error message is printed. 

Most of the work in this utility is actually performed by the TOOL object. 

@param ArgumentCount The number of command line arguments 

@param ArgumentVectors The list of pointers to the command line arguments 

@returns A standard windows error code.

**/

//**********************************************************************************************************************************

int main ( NUMBER     ArgumentCount,
           CHARACTER *ArgumentVectors [] )
{
   CHARACTER WorkingDirectoryName [ MAX_PATH_NAME ];

   printf ( TitleText );
   
   if ( ArgumentCount < 3 )
   {
      printf ( HelpText );
   }
   else
   {
      if ( ArgumentCount == 3 )
      {
         GetWorkingDirectory ( WorkingDirectoryName, sizeof ( WorkingDirectoryName ) );

         Tool = new TOOL ( ArgumentVectors [ 1 ], ArgumentVectors [ 2 ], WorkingDirectoryName );
      }

      if ( ArgumentCount == 4 )
      {
         Tool = new TOOL ( ArgumentVectors [ 1 ], ArgumentVectors [ 2 ], ArgumentVectors [ 3 ] );
      }

      if ( Tool != NULL )
      {
         Tool->Execute ();
      }
      else
      {
         printf ( "Cannot create TOOL\n" );
      }
   }
      
   return ( 0 );
}

//**********************************************************************************************************************************

CHARACTER *GetTitleText ( void )
{
   return ( TitleText );
}

//**********************************************************************************************************************************

CHARACTER *GetHelpText ( void )
{
   return ( HelpText );
}

//**********************************************************************************************************************************

TOOL *GetTool ( void )
{
   return ( Tool );
}

//**********************************************************************************************************************************

void Assertion ( bool  Condition,
                 char *FileName,
                 int   LineNumber )
{
   if ( !Condition )
   {
      printf ( "Assertion failed in file %s at line %d\n", FileName, LineNumber );

      exit ( 0 );
   }
}

//**********************************************************************************************************************************

NUMBER GetNumberOfRootFileTypes ( void )
{
   return ( NumberOfRootFileTypes );
}

NUMBER GetNumberOfMasterFileTypes ( void )
{
   return ( NumberOfMasterFileTypes );
}

NUMBER GetNumberOfTemplateFileTypes ( void )
{
   return ( NumberOfTemplateFileTypes );
}

NUMBER GetNumberOfSourceFileTypes ( void )
{
   return ( NumberOfSourceFileTypes );
}

//**********************************************************************************************************************************

INITIALISATION_TABLE_ENTRY *GetRootFileTypesTable ( void )
{
   return ( RootFileTypesTable );
}

INITIALISATION_TABLE_ENTRY *GetMasterFileTypesTable ( void )
{
   return ( MasterFileTypesTable );
}

INITIALISATION_TABLE_ENTRY *GetTemplateFileTypesTable ( void )
{
   return ( TemplateFileTypesTable );
}

INITIALISATION_TABLE_ENTRY *GetSourceFileTypesTable ( void )
{
   return ( SourceFileTypesTable );
}

//**********************************************************************************************************************************

/* splits a full file specification into its component parts */

void fnsplit ( CHARACTER *SourceFileName,
               CHARACTER *Drive,
               CHARACTER *Directory,
               CHARACTER *SourceName,
               CHARACTER *SourceExtension )

{
   CHARACTER *Dot;
   CHARACTER *Slash;
   CHARACTER *ScanPointer;
   BOOLEAN    FoundDrive           = FALSE;
   BOOLEAN    FoundDirectory       = FALSE;
   BOOLEAN    FoundSourceName      = FALSE;
   BOOLEAN    FoundSourceExtension = FALSE;

   Dot   = NULL;
   Slash = NULL;

   ScanPointer = SourceFileName;

   *Drive           = '\0';
   *Directory       = '\0';
   *SourceName      = '\0';
   *SourceExtension = '\0';

   /* check the beginning of the full file specification for the drive */

   if ( ( isascii ( SourceFileName [ 0 ] ) ) && ( SourceFileName [ 1 ] == ':' ) )
   {
      sprintf ( Drive, "%c:", SourceFileName [ 0 ] );

      ScanPointer = &SourceFileName [ 0 ];

      SourceFileName++; /* move past drive letter */
      SourceFileName++; /* move past semicolon    */

      FoundDrive = TRUE;
   }

   /* find the end of the full file specification and work backwards */

   ScanPointer = &SourceFileName [ strlen ( SourceFileName ) - 1 ];

   /* search for the '.' */

   while ( *ScanPointer != '.' )
   {
      if ( ScanPointer == SourceFileName ) break;

      ScanPointer--;
   }

   if ( *ScanPointer == '.' )
   {
      sprintf ( SourceExtension, "%s", ScanPointer );

      Dot = ScanPointer;

      FoundSourceExtension = TRUE;
   }

   /* search for the last directory seperator if any */

   while ( *ScanPointer != '\\' )
   {
      if ( ScanPointer == SourceFileName ) break;

      ScanPointer--;
   }

   if ( *ScanPointer == '\\' )
   {
      FoundSourceName = TRUE;

      if ( FoundSourceExtension ) *Dot = '\0';

      sprintf ( SourceName, "%s", &ScanPointer [ 1 ] );

      if ( FoundSourceExtension ) *Dot = '.';

      Slash = ScanPointer;

      *Slash = '\0';
   }

   /* whatever is left is the directory */

   sprintf ( Directory, "%s", SourceFileName );

   if ( FoundSourceName ) *Slash = '\\';
}

//**********************************************************************************************************************************

void OperatorConfidence ( void )

{
    printf ( "%c\r", WheelTable [ Wheel++ ] );

    if ( Wheel >= WheelTableSize )
    {
        Wheel = 0;
    }
}

void DisplayProgress ( NUMBER Current, 
	                   NUMBER Total )
{
	NUMBER Percentage = ( Current * 100 ) / Total;

    printf ( "%02d%%\r", Percentage );
}

//**********************************************************************************************************************************
